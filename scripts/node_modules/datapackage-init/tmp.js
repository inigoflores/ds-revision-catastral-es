  if (typeof path_ === 'string') {
    dir = path_;
  } else {
    var dir = process.cwd();
    cb = path_;
  }

/**
 * from urls to resources
 */
exports.urls2resources = function(urls, callback){
  urls = uniq(urls);

  async.map(urls, function(myurl, cb){

    cb = once(cb);

    request.head(myurl, function(err, res){
      if(err) return cb(err);

      if(res.statusCode >= 300){
        return cb(new Error('could not process ' + myurl + ' code (' + res.statusCode + ')'));
      }

      var mypath = url.parse(myurl).pathname;

      var resource = {
        name: path.basename(mypath, path.extname(mypath)),
        mediatype: res.headers['content-type'],
        format: mime.extension(res.headers['content-type']),
        url: myurl
      };

      if(resource.format === 'csv'){
        var req = request(myurl); 
        req.on('error', cb);
        req.on('response', function(res){
          if (res.statusCode >= 300){
            return cb(new Error('could not process ' + myurl + ' code (' + res.statusCode + ')'));
          } 

          jtsInfer(req, function(err, schema){
            if(err) return cb(err);
            resource.schema = schema;
            cb(null, resource);
          });
          
        });

      } else {
        cb(null, resource);
      }

    });

  }, callback);
  
};

/**
 * from paths expressed as globs (*.csv, ...) to resources
 */
Dpm.prototype.paths2resources = function(globs, callback){

  async.map(globs, function(pattern, cb){
    glob(path.resolve(this.root, pattern), {matchBase: true}, cb);
  }.bind(this), function(err, paths){    
    if(err) return cb(err);

    paths = uniq(flatten(paths));
    
    async.map(paths, function(p, cb){
      var ext = path.extname(p);
      
      var resource = {
        name: path.basename(p, ext),
        format: ext.substring(1),
        mediatype: mime.lookup(ext),
        path: path.relative(this.root, p)
      };

      //check that all path are within this.root if not throw error
      if(resource.path.indexOf('..') !== -1){
        return cb(new Error('only data files within ' + this.root + ' can be added (' + resource.path +')'));
      }

      if(resource.format === 'csv'){

        jtsInfer(fs.createReadStream(resource.path), function(err, schema){
          if(err) return cb(err);
          resource.schema = schema;
          cb(null, resource);
        });

      } else {
        cb(null, resource);
      }

    }.bind(this), callback);

  }.bind(this));
  
};


/**
 * add resources to dpkg.resources by taking care of removing previous
 * resources with conflicting names
 */
Dpm.prototype.addResources = function(dpkg, resources){

  if(!('resources' in dpkg)){
    dpkg.resources = [];
  }

  var names = resources.map(function(r) {return r.name;});
  dpkg.resources = dpkg.resources
    .filter(function(r){ return names.indexOf(r.name) === -1; })
    .concat(resources);

  return dpkg;  

};




